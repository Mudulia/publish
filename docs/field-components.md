# Field components

Publish calls *field components* to the components that are used to represent API field types in various contexts throughout the app. 

## Naming convention

Field components are all prefixed with the word *Field* followed by the type or sub-type of the respective field, with sub-type taking precedence over type. For example, `FieldString` represents a field with type `String`, whereas `FieldImage` represents a field with type `Reference` and sub-type `Image`.

The sub-type is defined in [the `publish` block](#publish-specific-fields.md).

## Dynamic loading

For the various parts of the app to know which field components are available, we have Webpack looking for all field components and generating a JavaScript file with all the appropriate imports. It looks like this:

```js
// Generated by Webpack. Do not change or commit!
import * as FieldBoolean from 'frontend/components/FieldBoolean/FieldBoolean'
import * as FieldDateTime from 'frontend/components/FieldDateTime/FieldDateTime'
import * as FieldImage from 'frontend/components/FieldImage/FieldImage'
import * as FieldNumber from 'frontend/components/FieldNumber/FieldNumber'
import * as FieldReference from 'frontend/components/FieldReference/FieldReference'
import * as FieldString from 'frontend/components/FieldString/FieldString'

export {FieldBoolean, FieldDateTime, FieldImage, FieldNumber, FieldReference, FieldString}
```

Any app component that wishes to use field components just needs to import a single file, and can easily check whether there's a field component available for their type/sub-type:

```js
// Loading field components
import * as fieldComponents from 'lib/field-components'

// Checking if `FieldString` is available
if (fieldComponents.FieldString) {
  doSomething()
}
```

## Contexts

A field component may wish to specify how it's represented in various contexts. Some of them are required, meaning that the app isn't capable of providing a fallback. These are the ones currently supported:

| Key  | Description                                                                      | Required |
|------|----------------------------------------------------------------------------------|----------|
| edit | How the field is represented in the document edit view                           | **yes**  |
| list | How the field is represented inside its table cell within the document list view | no       |

Components should have, within their directory, a separate file for each of the contexts they wish to implement, and then have the entry point file exporting those contexts to the app. For example, this shows the directory structure for `FieldString`, which implements the `edit` and `list` contexts:

```
FieldString
├── FieldString.css
├── FieldString.jsx
├── FieldStringEdit.jsx
└── FieldStringList.jsx
```

*Entry point (FieldString.jsx):*

```js
import edit from './FieldStringEdit'
import list from './FieldStringList'

export {edit, list}
```